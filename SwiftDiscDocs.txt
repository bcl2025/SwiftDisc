SwiftDisc Developer Documentation
=================================

Overview
--------
SwiftDisc is a Swift-native library for the Discord API, inspired by discord.py and built on Swift concurrency. It targets iOS, macOS, tvOS, watchOS, and Windows (where supported by Foundation networking).

Architecture
------------
- Package layout:
  - Sources/SwiftDisc
    - Internal: Config and shared error types
    - Models: Core data models (Snowflake, User, Channel, Message, Embed, Attachment, Role, GuildMember, GuildBan, GuildWidgetSettings)
    - REST: HTTP client and rate limiter
    - Gateway: WebSocket abstraction, gateway models, actor-based client
    - HighLevel: CommandRouter, SlashCommandRouter, ShardManager, Utilities
    - DiscordClient.swift: High-level facade (REST + Gateway orchestration)
  - Tests/SwiftDiscTests: Unit tests

Key Modules
-----------
1) DiscordClient (High-level API)
   - loginAndConnect(intents:): Connects to the Gateway and begins streaming events.
   - events: AsyncStream<DiscordEvent> to consume gateway events.
   - getCurrentUser(): Fetches the current bot user via REST.
   - sendMessage(channelId:content:/embeds/components): Sends messages with content, embeds, or components.
   - editMessage/getMessage/listChannelMessages: Manage messages.
   - REST helpers across Channels, Guilds, Members, Roles, Bans, Webhooks, Interactions.
   - loginAndConnectSharded(index:total:): Sharded gateway connect helper.
   - setPresence(status:activities:afk:since:): Presence update.

2) REST Layer
   - HTTPClient: GET/POST/PATCH/DELETE/PUT with Authorization header; retries/backoff for 429/5xx.
   - RateLimiter: Per-route buckets honoring X-RateLimit-* and global limits with backoff; Retry-After respected.
   - Errors: DiscordError covering HTTP, API payload (message/code), encoding/decoding, network.

3) Gateway Layer
   - WebSocket abstraction: URLSessionWebSocketAdapter (unified across platforms where supported).
   - Models: GatewayOpcode, GatewayPayload, GatewayHello, IdentifyPayload, Intents, ReadyEvent.
   - Client (actor): Connects, receives HELLO, sends Identify/Resume, maintains heartbeat with ACK tracking, auto-reconnect with exponential backoff, preserves shard, decodes events and streams via event sink.
   - ShardManager: Orchestrates multiple DiscordClient shards in parallel.

Intents
-------
- GatewayIntents is an OptionSet of UInt64.
- Common useful intents: .guilds, .guildMessages, .messageContent (privileged).
- You must enable privileged intents (like message content) in the Discord Developer Portal.

Events
------
- Current: READY, MESSAGE_CREATE, GUILD_CREATE, CHANNEL_CREATE/UPDATE/DELETE, INTERACTION_CREATE, VOICE_STATE_UPDATE, VOICE_SERVER_UPDATE.
- Access via DiscordClient.events (AsyncStream<DiscordEvent>).

High-Level Routers
------------------
- CommandRouter (prefix):
  - Register commands via `register("name", description:, handler:)` and optional `onError` callback.
  - Generate help text via `helpText()`.
- SlashCommandRouter:
  - Register by command name or full path `registerPath("admin ban")`.
  - Typed accessors: `string`, `int`, `bool`, `double`.
  - Subcommands/groups supported via full-path resolution; optional `onError`.

Usage Examples
--------------
- Connecting with intents:
  try await client.loginAndConnect(intents: [.guilds, .guildMessages, .messageContent])

- Handling events:
  for await event in client.events {
      switch event {
      case .ready(let info):
          print("Logged in as: \(info.user.username)")
      case .messageCreate(let msg):
          print("#\(msg.channel_id): \(msg.author.username): \(msg.content)")
      }
  }

- Sending a message:
  let sent: Message = try await client.sendMessage(channelId: "123456789012345678", content: "Hello from SwiftDisc!")

- Sending embeds and components:
  let embed = Embed(title: "Hi", description: "Hello", color: 0x5865F2)
  let btn = MessageComponent.Button(style: 1, label: "Click", custom_id: "btn_1")
  let row = MessageComponent.ActionRow(components: [.button(btn)])
  _ = try await client.sendMessage(channelId: ch.id, content: nil, embeds: [embed], components: [.actionRow(row)])

- REST examples:
  let ch: Channel = try await client.getChannel(id: "123456789012345678")
  let ch2: Channel = try await client.modifyChannelName(id: ch.id, name: "general")
  try await client.deleteMessage(channelId: ch.id, messageId: "987654321098765432")
  let guild: Guild = try await client.getGuild(id: "111111111111111111")
  try await client.createInteractionResponse(interactionId: "222222222222222222", token: "tok", content: "Pong!")
  let hook: Webhook = try await client.createWebhook(channelId: ch.id, name: "MyHook")
  let viaHook: Message = try await client.executeWebhook(webhookId: hook.id, token: hook.token ?? "", content: "Hi from webhook")
  let member: GuildMember = try await client.getGuildMember(guildId: guild.id, userId: "333333333333333333")
  let roles: [Role] = try await client.listGuildRoles(guildId: guild.id)
  let bans: [GuildBan] = try await client.listGuildBans(guildId: guild.id)
  _ = try await client.triggerTypingIndicator(channelId: ch.id)

Platform Notes
--------------
- Windows: Uses URLSessionNetworking where available; if unavailable, gateway will report unsupported WebSocket.
- iOS/watchOS: Be mindful of background execution limits for long-lived WebSocket connections.

Error Handling
--------------
- DiscordError.http(status, body): Non-2xx HTTP responses.
- DiscordError.encoding/decoding: JSON issues.
- DiscordError.network: Transport errors (URLSession).
- DiscordError.gateway: Gateway protocol or platform-specific WebSocket issues.

Rate Limiting
-------------
- Per-route buckets with automatic retries and backoff; honors X-RateLimit-* and global limits. Retry-After respected; exponential backoff for 5xx.

Sharding
--------
- Use `ShardManager(token:totalShards).start(intents:)` to orchestrate multiple shards.
- Or call `loginAndConnectSharded(index:total:intents:)` on individual clients.
- Resume preserves session/shard; reconnect uses exponential backoff.

Production Deployment
---------------------
- Build & Run: SwiftPM build; run with `DISCORD_TOKEN`.
- Supervisor: systemd/launchd/PM2/Docker for uptime.
- Config: Set intents in Developer Portal; configure shard count.
- Environment: Logging, outbound access to Discord, clock sync.
- Scaling: Horizontal sharding; respect rate limits.
- Secrets: Never commit tokens; use env vars or secure stores.
- CI/CD: GitHub Actions provided; add deploy job to your infra.

Testing Strategy
----------------
- REST: Use URLProtocol mocking to simulate HTTP responses.
- Gateway: Provide a mock WebSocket to simulate HELLO, DISPATCH, and HEARTBEAT frames.
- Add assertions for identify, heartbeat cadence, and event decoding.

Security
--------
- Never hardcode bot tokens. Use environment variables or secure storage.
- Privileged intents require proper justification and compliance with Discord policies.

Versioning & Changelog
----------------------
- Semantic Versioning (MAJOR.MINOR.PATCH) with pre-release tags (e.g., 0.1.0-alpha).
- All changes documented in CHANGELOG.md.

Roadmap Highlights
------------------
- Gateway: Resume/reconnect, heartbeat ACK tracking, presence updates, sharding (implemented).
- REST: Per-route buckets, error model decoding, expanding endpoints coverage (implemented and growing).
- High-level: Command helpers, caching layer, callback adapter for UI frameworks.
- Cross-platform: Windows WebSocket adapter and CI (implemented).

Support
-------
- Discord: https://discord.com/invite/r4rCAXvb8d
- Issues/requests: GitHub Issues on the project repository.

Contributing
------------
- Open an issue to discuss significant changes.
- Follow Swift API Design Guidelines and keep public APIs concise and well-documented.
- Include tests with changes when possible.
